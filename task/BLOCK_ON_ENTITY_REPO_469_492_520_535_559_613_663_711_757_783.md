# Remove block_on from entity.rs - Return Futures Instead (HIGH)

**Locations:**
- `src/memory/graph/entity.rs:469` - create_entity
- `src/memory/graph/entity.rs:492` - get_entity
- `src/memory/graph/entity.rs:520` - update_entity
- `src/memory/graph/entity.rs:535` - delete_entity
- `src/memory/graph/entity.rs:559` - list_entities_by_type
- `src/memory/graph/entity.rs:613` - count_entities_by_type
- `src/memory/graph/entity.rs:663` - batch_create_entities
- `src/memory/graph/entity.rs:711` - batch_update_entities
- `src/memory/graph/entity.rs:757` - batch_delete_entities
- `src/memory/graph/entity.rs:783` - (related to batch operations)

**Priority:** HIGH - Breaking consistency with rest of memory system

## Current Code Pattern

```rust
fn create_entity(&self, entity: Box<dyn Entity>) -> Result<Box<dyn Entity>> {
    entity.validate()?;
    let node = entity.to_node();
    
    // WRONG: Spawns thread, blocks on result
    let _created_node_id = self.execute_db_operation(move |db| {
        let pending_node = db.create_node(node.properties);
        let rt = crate::runtime::shared_runtime()
            .ok_or_else(|| GraphError::DatabaseError("Runtime unavailable".to_string()))?;
        rt.block_on(pending_node)  // ← Line 469: blocking!
    })?;
    
    Ok(created_entity)
}

// execute_db_operation spawns thread + blocks on channel:
fn execute_db_operation<F, T>(&self, operation: F) -> Result<T>
where
    F: FnOnce(Arc<dyn GraphDatabase>) -> Result<T> + Send + 'static,
{
    let db = self.db.clone();
    let (sender, receiver) = unbounded();

    thread::spawn(move || {
        let result = operation(db);
        let _ = sender.send(result);
    });

    receiver.recv()  // ← Blocking!
        .map_err(|_| GraphError::Other("Database operation thread failed".to_string()))?
}
```

## Problem: Inconsistent with Memory System Pattern

The rest of the memory system uses **sync methods that RETURN futures**:
- `multimodal_service.rs` - `embed_image()` returns `PendingEmbedding`
- Memory operations return `PendingBatchEmbedding`, etc.

But `EntityRepository` trait methods return `Result<T>` and block internally using:
1. Thread spawning
2. Channel blocking
3. `runtime.block_on()` inside thread

This breaks the pattern. Methods should return future wrappers.

## Solution: Return Futures Like Rest of Memory System

### Step 1: Define Future Wrapper Types

```rust
// In src/memory/graph/entity.rs

use tokio::sync::oneshot;

pub struct PendingEntity {
    rx: oneshot::Receiver<Result<Box<dyn Entity>>>,
}

impl PendingEntity {
    pub fn new(rx: oneshot::Receiver<Result<Box<dyn Entity>>>) -> Self {
        Self { rx }
    }
}

impl std::future::Future for PendingEntity {
    type Output = Result<Box<dyn Entity>>;
    
    fn poll(mut self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
        match std::pin::Pin::new(&mut self.rx).poll(cx) {
            std::task::Poll::Ready(Ok(result)) => std::task::Poll::Ready(result),
            std::task::Poll::Ready(Err(_)) => std::task::Poll::Ready(Err(GraphError::Other("Channel closed".to_string()))),
            std::task::Poll::Pending => std::task::Poll::Pending,
        }
    }
}

// Similar for:
// - PendingEntityOption (for get_entity)
// - PendingEntityList (for list_entities_by_type)
// - PendingEntityCount (for count_entities_by_type)
// - PendingUnit (for delete_entity)
// - PendingEntityBatch (for batch operations)
```

### Step 2: Update EntityRepository Trait

```rust
pub trait EntityRepository: Send + Sync {
    fn create_entity(&self, entity: Box<dyn Entity>) -> PendingEntity;
    fn get_entity(&self, id: &str) -> PendingEntityOption;
    fn update_entity(&self, entity: Box<dyn Entity>) -> PendingEntity;
    fn delete_entity(&self, id: &str) -> PendingUnit;
    fn list_entities_by_type(
        &self,
        entity_type: &str,
        limit: Option<usize>,
        offset: Option<usize>,
    ) -> PendingEntityList;
    fn count_entities_by_type(&self, entity_type: &str) -> PendingEntityCount;
    fn batch_create_entities(&self, entities: Vec<Box<dyn Entity>>) -> PendingEntityBatch;
    fn batch_update_entities(&self, entities: Vec<Box<dyn Entity>>) -> PendingEntityBatch;
    fn batch_delete_entities(&self, ids: Vec<String>) -> PendingUnit;
}
```

### Step 3: Implement Using tokio::spawn (NO block_on!)

```rust
impl<E: Entity + Clone + 'static> EntityRepository for SurrealEntityRepository<E> {
    fn create_entity(&self, entity: Box<dyn Entity>) -> PendingEntity {
        // Validate synchronously
        if let Err(e) = entity.validate() {
            let (tx, rx) = oneshot::channel();
            let _ = tx.send(Err(e));
            return PendingEntity::new(rx);
        }
        
        let node = entity.to_node();
        let db = self.db.clone();
        let (tx, rx) = oneshot::channel();
        
        tokio::spawn(async move {
            // NO block_on - just .await!
            let result = db.create_node(node.properties).await
                .map_err(|e| GraphError::DatabaseError(e.to_string()))
                .map(|_| entity);
            let _ = tx.send(result);
        });
        
        PendingEntity::new(rx)
    }
    
    fn get_entity(&self, id: &str) -> PendingEntityOption {
        let id = id.to_string();
        let db = self.db.clone();
        let (tx, rx) = oneshot::channel();
        
        tokio::spawn(async move {
            let result = db.get_node(&id).await
                .map_err(|e| GraphError::DatabaseError(e.to_string()))
                .map(|opt| opt.map(|node| {
                    // Convert node to entity
                    Box::new(E::from_node(node)) as Box<dyn Entity>
                }));
            let _ = tx.send(result);
        });
        
        PendingEntityOption::new(rx)
    }
    
    // Similar pattern for other 7 methods
}
```

### Step 4: Delete execute_db_operation

Remove the entire `execute_db_operation` method - it's no longer needed.

**Pattern Explanation:**
- **ANTIPATTERN (current):** Sync method returns `Result<T>`, blocks internally with thread + channel + runtime.block_on()
- **CORRECT (fix):** Sync method returns `Pending<T>`, spawns tokio task with .await, caller awaits result

## Implementation Notes

1. Define all Pending* wrapper types (9 types needed)
2. Update EntityRepository trait signatures
3. Update SurrealEntityRepository implementation (9 methods)
4. Delete execute_db_operation method entirely
5. Update all call sites to `.await` the returned futures
6. This matches the pattern used in multimodal_service.rs

## Files to Modify

- `src/memory/graph/entity.rs` - Define Pending types, update trait and impl
- Find all call sites of EntityRepository methods and add `.await`

## Benefits

1. Consistent with rest of memory system
2. No thread spawning overhead
3. No channel blocking
4. No runtime.block_on()
5. Proper async without blocking
6. Caller controls when to await
