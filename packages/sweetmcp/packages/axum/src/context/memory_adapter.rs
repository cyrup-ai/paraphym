//! Memory system adapter for context API
//! This module provides integration between MCP context API and the sophisticated memory system

use std::sync::Arc;

use anyhow::Result;
use serde_json::Value;
use tokio::sync::RwLock;
use chrono;
use uuid;

// Production memory system from paraphym_candle
use paraphym_candle::memory::core::manager::surreal::SurrealDBMemoryManager;
use paraphym_candle::memory::{MemoryManager, MemoryNode, MemoryMetadata}; // Import trait and correct types
use paraphym_candle::memory::core::primitives::types::{MemoryTypeEnum, MemoryContent};
use futures::StreamExt; // For stream handling from async methods
use serde_json::json;
use std::collections::HashMap;

/// Production memory adapter using SurrealDB with automatic BERT embedding generation
#[derive(Clone)]
pub struct MemoryContextAdapter {
    memory_manager: Arc<SurrealDBMemoryManager>,
    subscriptions: Arc<RwLock<Vec<String>>>,
}

impl MemoryContextAdapter {
    /// Create a new memory context adapter with production memory system
    pub async fn new() -> Result<Self> {
        // Initialize SurrealDB with SurrealKV backend using Any engine
        let db = surrealdb::engine::any::connect(
            "surrealkv://./data/context_memory.db"
        ).await
        .map_err(|e| anyhow::anyhow!("Failed to connect to SurrealDB: {}", e))?;
        
        // Use namespace and database
        db.use_ns("context").use_db("mcp").await
            .map_err(|e| anyhow::anyhow!("Failed to select namespace/database: {}", e))?;
        
        // Create SurrealDBMemoryManager with embeddings (assumes MEMFIX_1/2 completed)
        let manager = SurrealDBMemoryManager::with_embeddings(db).await
            .map_err(|e| anyhow::anyhow!("Failed to create manager with embeddings: {}", e))?;
        
        // Initialize schema and indexes
        manager.initialize().await
            .map_err(|e| anyhow::anyhow!("Failed to initialize schema: {}", e))?;
        
        Ok(Self {
            memory_manager: Arc::new(manager),
            subscriptions: Arc::new(RwLock::new(Vec::new())),
        })
    }

    /// Store context value using production memory system with automatic BERT embeddings
    /// Updates existing context if key already exists, creates new one otherwise
    pub async fn store_context(&self, key: String, value: Value) -> Result<()> {
        let json_str = serde_json::to_string(&value)?;
        
        // Check if context exists using direct database query
        let existing = self.find_context_memory(&key).await?;
        
        if let Some(mut existing_memory) = existing {
            // Update existing memory node
            existing_memory.content = MemoryContent::new(&json_str);
            existing_memory.updated_at = chrono::Utc::now();
            // Update custom metadata (it's a JSON Value)
            if let Some(obj) = existing_memory.metadata.custom.as_object_mut() {
                obj.insert(
                    "updated_at".to_string(), 
                    json!(chrono::Utc::now().timestamp_millis())
                );
            }
            
            // Use update_memory which returns PendingMemory (Future)
            self.memory_manager
                .update_memory(existing_memory)
                .await
                .map_err(|e| anyhow::anyhow!("Failed to update context: {}", e))?;
        } else {
            // Create new memory node with metadata
            let memory = MemoryNode {
                id: uuid::Uuid::new_v4().to_string(),
                content: MemoryContent::new(&json_str),
                memory_type: MemoryTypeEnum::Semantic,
                created_at: chrono::Utc::now(),
                updated_at: chrono::Utc::now(),
                embedding: None, // Will be auto-generated by manager
                metadata: MemoryMetadata {
                    user_id: None,
                    agent_id: None,
                    context: "mcp".to_string(),
                    keywords: Vec::new(),
                    tags: Vec::new(),
                    category: "context".to_string(),
                    importance: 1.0,
                    source: Some("mcp_context_api".to_string()),
                    created_at: chrono::Utc::now(),
                    last_accessed_at: Some(chrono::Utc::now()),
                    embedding: None,
                    custom: json!({
                        "type": "context",
                        "key": key
                    }),
                },
            };
            
            // Use create_memory which returns PendingMemory (Future)
            self.memory_manager
                .create_memory(memory)
                .await
                .map_err(|e| anyhow::anyhow!("Failed to create context: {}", e))?;
        }
        
        Ok(())
    }

    /// Retrieve context value from production memory using metadata filtering
    pub async fn get_context(&self, key: &str) -> Result<Option<Value>> {
        if let Some(memory) = self.find_context_memory(key).await? {
            let value: Value = serde_json::from_str(&memory.content.text)?;
            Ok(Some(value))
        } else {
            Ok(None)
        }
    }

    /// Helper method to find a context memory by key
    async fn find_context_memory(&self, key: &str) -> Result<Option<MemoryNode>> {
        // Build metadata filters for query
        let mut filters = HashMap::new();
        filters.insert("type".to_string(), json!("context"));
        filters.insert("key".to_string(), json!(key));
        
        // Query database directly using metadata filters
        // query_by_metadata returns a MemoryStream
        let mut stream = self.memory_manager
            .query_by_metadata(filters)
            .await
            .map_err(|e| anyhow::anyhow!("Failed to query memory: {}", e))?;
        
        // Get first matching result from stream
        if let Some(result) = stream.next().await {
            match result {
                Ok(memory) => Ok(Some(memory)),
                Err(e) => Err(anyhow::anyhow!("Failed to read memory: {}", e))
            }
        } else {
            Ok(None)
        }
    }

    /// Add a subscription
    pub async fn add_subscription(&self, uri: String) -> Result<()> {
        let mut subs = self.subscriptions.write().await;
        if !subs.contains(&uri) {
            subs.push(uri);
        }
        Ok(())
    }

    /// Remove a subscription
    pub async fn remove_subscription(&self, uri: &str) -> Result<()> {
        let mut subs = self.subscriptions.write().await;
        subs.retain(|s| s != uri);
        Ok(())
    }

    /// Get all active subscriptions
    pub async fn get_subscriptions(&self) -> Vec<String> {
        self.subscriptions.read().await.clone()
    }

    /// Search using production semantic search with BERT embeddings
    /// 
    /// # Arguments
    /// * `pattern` - The search pattern/query
    /// * `limit` - Maximum number of results to return (default: 10, max: 100)
    pub async fn search_contexts(&self, pattern: &str, limit: Option<usize>) -> Result<Vec<(String, Value)>> {
        let search_limit = limit.unwrap_or(10).min(100);
        
        // Use semantic search with embeddings (added in MEMFIX_1)
        // search_by_text returns a MemoryStream
        let mut stream = self.memory_manager
            .search_by_text(pattern, search_limit)
            .await
            .map_err(|e| anyhow::anyhow!("Search failed: {}", e))?;
        
        let mut results = Vec::new();
        
        // Process stream of search results
        while let Some(memory_result) = stream.next().await {
            match memory_result {
                Ok(memory) => {
                    // Check if this is a context entry
                    if let Some(type_val) = memory.metadata.custom.get("type") {
                        if type_val.as_str() == Some("context") {
                            if let Some(key_val) = memory.metadata.custom.get("key") {
                                if let Some(key) = key_val.as_str() {
                                    // Parse content back to JSON Value
                                    let value: Value = serde_json::from_str(&memory.content.text)
                                        .unwrap_or_else(|_| json!(null));
                                    results.push((key.to_string(), value));
                                }
                            }
                        }
                    }
                }
                Err(e) => {
                    log::warn!("Error processing search result: {}", e);
                }
            }
        }
        
        Ok(results)
    }

    /// Graceful shutdown with proper resource cleanup
    pub async fn shutdown(&self) -> Result<()> {
        log::info!("Shutting down MemoryContextAdapter...");
        
        // Clear all subscriptions
        let mut subs = self.subscriptions.write().await;
        let sub_count = subs.len();
        subs.clear();
        drop(subs); // Explicitly drop write lock

        log::info!("Cleared {} subscriptions", sub_count);

        // Note: MemoryCoordinator and SurrealDB connections are cleaned up
        // automatically when the Arc is dropped. The Surreal<Any> connection
        // has a proper Drop implementation that closes the connection.
        log::info!("MemoryContextAdapter shutdown complete. Database connections will be closed on Arc drop.");
        
        Ok(())
    }

    /// Validate memory system
    pub async fn validate(&self) -> Result<()> {
        // Test search functionality with timeout
        // search_by_text should be available after MEMFIX_1
        match tokio::time::timeout(
            std::time::Duration::from_secs(5),
            async {
                let mut stream = self.memory_manager
                    .search_by_text("__health_check__", 1)
                    .await?;
                // Just check if we can execute the search
                stream.next().await;
                Ok::<(), anyhow::Error>(())
            }
        ).await {
            Ok(Ok(_)) => {
                log::debug!("Memory system validation passed");
                Ok(())
            }
            Ok(Err(e)) => {
                Err(anyhow::anyhow!("Validation failed: {}", e))
            }
            Err(_) => {
                Err(anyhow::anyhow!("Validation timeout"))
            }
        }
    }

    /// Get real statistics from memory system using efficient metadata filtering
    pub async fn get_stats(&self) -> MemoryStats {
        // Build filter for context entries
        let mut filters = HashMap::new();
        filters.insert("type".to_string(), json!("context"));
        
        // Query all context memories (uses query_by_metadata from MEMFIX_2)
        match self.memory_manager.query_by_metadata(filters).await {
            Ok(mut stream) => {
                let mut total_nodes = 0;
                let mut total_relationships = 0;
                
                // Count nodes and their relationships
                while let Some(result) = stream.next().await {
                    if let Ok(memory) = result {
                        total_nodes += 1;
                        
                        // Get relationships for this node
                        // get_relationships returns RelationshipStream
                        let mut rel_stream = self.memory_manager
                            .get_relationships(&memory.id);
                        
                        // Count relationships
                        while let Some(rel_result) = rel_stream.next().await {
                            if rel_result.is_ok() {
                                total_relationships += 1;
                            }
                        }
                    }
                }
                
                MemoryStats {
                    total_nodes,
                    total_relationships,
                }
            }
            Err(e) => {
                log::warn!("Failed to get stats: {}", e);
                MemoryStats {
                    total_nodes: 0,
                    total_relationships: 0,
                }
            }
        }
    }
}

/// Memory adapter statistics
#[derive(Debug, Clone)]
pub struct MemoryStats {
    pub total_nodes: usize,
    pub total_relationships: usize,
}
